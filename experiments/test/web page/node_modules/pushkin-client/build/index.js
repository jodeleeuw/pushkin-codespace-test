"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _axios = _interopRequireDefault(require("axios"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Pushkin = /*#__PURE__*/function () {
  function Pushkin() {
    _classCallCheck(this, Pushkin);
    this.con = undefined;
  }
  _createClass(Pushkin, [{
    key: "connect",
    value: function connect(quizAPIUrl) {
      this.con = _axios["default"].create({
        baseURL: quizAPIUrl
      });
    }
  }, {
    key: "loadScript",
    value: function loadScript(url) {
      return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          return reject("Loading timed out for ".concat(url));
        }, 5000);

        // check if this script is already loaded and reload if it is
        // can't use array 'has' because getElements doesn't return an array
        var scripts = document.getElementsByTagName('script');
        for (var i = 0; i < scripts.length; i++) {
          if (scripts[i].src == url) scripts[i].parentNode.removeChild(scripts[i]);
        }
        var script = document.createElement('script');
        script.onload = function () {
          clearTimeout(timeout);
          resolve(script);
        };
        script.src = url;
        document.body.appendChild(script);
      });
    }
  }, {
    key: "loadScripts",
    value: function loadScripts(urls) {
      return Promise.all(urls.map(this.loadScript));
    }
  }, {
    key: "tabulateAndPostResults",
    value: function tabulateAndPostResults(userID, experiment) {
      var postData = {
        user_id: userID,
        experiment: experiment
      };
      return this.con.post('/tabulateAndPostResults', postData);
    }
  }, {
    key: "prepExperimentRun",
    value: function prepExperimentRun(userID) {
      var postData = {
        user_id: userID
      };
      return this.con.post('/startExperiment', postData);
    }
  }, {
    key: "getAllStimuli",
    value: function getAllStimuli(userID, nItems) {
      var postData = {
        user_id: userID,
        nItems: nItems
      };
      return this.con.post('/getStimuli', postData).then(function (res) {
        return JSON.parse(res).data.resData; //send back just the stimuli
      });
    }
  }, {
    key: "setSaveAfterEachStimulus",
    value: function setSaveAfterEachStimulus(stimuli) {
      var _this = this;
      //Deprecated. Don't use. Instead us
      //  const jsPsych = initJsPsych({
      //     ...
      //     on_data_update: pushkin.saveStimulusResponse(data),
      //  });

      var saveWrapper = function saveWrapper(timeline) {
        return timeline.map(function (s) {
          return s.hasOwnProperty('timeline') ? _objectSpread(_objectSpread({}, s), {}, {
            on_finish: function on_finish(data) {
              if (s.on_finish) s.on_finish(data); // If s already has an on_finish, call it
              return _this.saveStimulusResponse.bind(_this)(data); // bind(this) is necessary because of `this` in saveStimulusResponse
            },

            timeline: saveWrapper(s.timeline)
          }) : _objectSpread(_objectSpread({}, s), {}, {
            on_finish: function on_finish(data) {
              if (s.on_finish) s.on_finish(data); // If s already has an on_finish, call it
              return _this.saveStimulusResponse.bind(_this)(data); // bind(this) is necessary because of `this` in saveStimulusResponse
            }
          });
        });
      };

      return saveWrapper(stimuli);
    }
  }, {
    key: "saveStimulusResponse",
    value: function saveStimulusResponse(data) {
      // Because we are saving data, it should be coming with a userID already
      // Might make sense at some point to confirm this is what we expect
      var stimulus;
      try {
        stimulus = data.stimulus;
      } catch (e) {
        throw new Error('jsPsych data does not include a stimulus key');
      }
      var user_id;
      try {
        user_id = data.user_id;
      } catch (e) {
        throw new Error('req does not include a user_id');
      }
      var postData = {
        user_id: user_id,
        data_string: data,
        stimulus: stimulus
      };
      return this.con.post('/stimulusResponse', postData);
    }
  }, {
    key: "insertMetaResponse",
    value: function insertMetaResponse(data) {
      var metaQuestion;
      try {
        metaQuestion = data.stimulus;
      } catch (e) {
        throw new Error('jsPsych data does not include a stimulus key');
      }
      var user_id;
      try {
        user_id = data.user_id;
      } catch (e) {
        throw new Error('req does not include a user_id');
      }
      var postData = {
        user_id: user_id,
        data_string: data,
        metaQuestion: metaQuestion
      };
      return this.con.post('/insertMetaResponse', postData);
    }
  }, {
    key: "endExperiment",
    value: function endExperiment(userID) {
      var postData = {
        user_id: userID
      };
      return this.con.post('/endExperiment', postData);
    }
  }, {
    key: "customApiCall",
    value: function customApiCall(path, data, httpMethod) {
      var _this2 = this;
      httpMethod = httpMethod || 'post';
      return new Promise(function (resolve, reject) {
        _this2.con[httpMethod](path, data).then(function (response) {
          // parse it if it's JSON, leave it otherwise
          try {
            response = JSON.parse(response);
          } catch (e) {}
          var resData = response.data && response.data.resData ? response.data.resData : null;
          resolve(resData);
        })["catch"](function (err) {
          reject(err);
        });
      });
    }
  }]);
  return Pushkin;
}();
exports["default"] = Pushkin;