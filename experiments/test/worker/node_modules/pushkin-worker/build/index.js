"use strict";

require("core-js/stable");

require("regenerator-runtime/runtime");

var _amqplib = _interopRequireDefault(require("amqplib"));

var _knex = _interopRequireDefault(require("knex"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var trim = function trim(s, len) {
  return s.length > len ? s.substring(0, len) : s;
};

var mysql_real_escape_string = function mysql_real_escape_string(str) {
  //Thanks https://stackoverflow.com/a/7760578/3291354
  return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (_char) {
    switch (_char) {
      case "\0":
        return "\\0";

      case "\x08":
        return "\\b";

      case "\x09":
        return "\\t";

      case "\x1a":
        return "\\z";

      case "\n":
        return "\\n";

      case "\r":
        return "\\r";

      case "\"":
      case "'":
      case "\\":
      case "%":
        return "\\" + _char;
      // prepends a backslash to backslash, percent,
      // and double/single quotes

      default:
        return _char;
    }
  });
};

var PushkinWorker = /*#__PURE__*/function () {
  function PushkinWorker(options) {
    _classCallCheck(this, PushkinWorker);

    this.amqpAddress = options.amqpAddress;
    this.readQueue = options.readQueue;
    this.writeQueue = options.writeQueue;
    this.taskQueue = options.taskQueue;
    this.conn = undefined;
    this.initialized = false;
    this.handlers = new Map();
  }

  _createClass(PushkinWorker, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  _amqplib["default"].connect(_this.amqpAddress).then(function (conn) {
                    _this.conn = conn;
                    _this.initialized = true;
                    console.log('Worker connected to message queue');
                    resolve();
                  })["catch"](function (err) {
                    reject("Error connecting to message queue: ".concat(err));
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "handle",
    value: function handle(method, handler) {
      this.handlers.set(method, handler);
    } // useDefaultHandles(dbUrl, dbTablePrefix, transactionOps) {
    // 	const handler = new defaultHandler(dbUrl, dbTablePrefix, transactionOps);
    // 	defaultMethods.forEach(h => {
    // 		this.handle(h, handler[h].bind(handler));
    // 	});
    // }

  }, {
    key: "useHandler",
    value: function useHandler(ahandler, connection, dbTablePrefix, transactionOps) {
      var _this2 = this;

      var handler = new ahandler(connection, dbTablePrefix, transactionOps);
      var methods = handler.methods();
      methods.forEach(function (h) {
        _this2.handle(h, handler[h].bind(handler));
      });
    }
  }, {
    key: "start",
    value: function start() {
      var _this3 = this;

      this.conn.createChannel().then(function (ch) {
        ch.assertQueue(_this3.readQueue, {
          durable: false
        });
        ch.assertQueue(_this3.writeQueue, {
          durable: true
        });
        ch.assertQueue(_this3.taskQueue, {
          durable: false
        });
        ch.prefetch(1);

        var consumeCallback = function consumeCallback(msg) {
          console.log("got message: ".concat(msg.content.toString()));
          Promise.resolve(JSON.parse(msg.content)).then(function (req) {
            if (!req || !req.method || req.data === undefined) throw new Error('requests must have a method and data field'); // try to call a handler

            if (!_this3.handlers.has(req.method)) throw new Error("no handler found to handle method ".concat(req.method));
            var sessId = req.sessionId;
            return _this3.handlers.get(req.method)(sessId, req.data, req.params);
          }).then(function (res) {
            // Is anyone actually reading this response? I don't think so...
            console.log("responding ".concat(JSON.stringify(res)));
            ch.sendToQueue(msg.properties.replyTo, new Buffer.from(JSON.stringify(res)), {
              correlationId: msg.properties.correlationId
            });
            ch.ack(msg);
          })["catch"](function (err) {
            console.error(err);
            ch.ack(msg);
            ch.sendToQueue(msg.properties.replyTo, new Buffer.from(JSON.stringify(err)), {
              correlationId: msg.properties.correlationId
            });
          });
        };

        console.log("consuming on ".concat(_this3.readQueue));
        ch.consume(_this3.readQueue, consumeCallback);
        console.log("consuming on ".concat(_this3.writeQueue));
        ch.consume(_this3.writeQueue, consumeCallback);
        console.log("consuming on ".concat(_this3.taskQueue));
        ch.consume(_this3.taskQueue, consumeCallback);
      })["catch"](function (err) {
        console.error("failed to created channel: ".concat(err));
      });
    }
  }]);

  return PushkinWorker;
}(); // helper function for turning string *or* JSON into string


function handleJSON(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return str;
  }

  return JSON.stringify(str);
}

var DefaultHandler = /*#__PURE__*/function () {
  function DefaultHandler(connection, dbTablePrefix, transactionOps) {
    _classCallCheck(this, DefaultHandler);

    this.tables = {
      users: "pushkin_users",
      userResults: "pushkin_userResults",
      userMeta: "pushkin_userMeta",
      stim: "".concat(dbTablePrefix, "_stimuli"),
      stimResp: "".concat(dbTablePrefix, "_stimulusResponses"),
      stimGroups: "".concat(dbTablePrefix, "_stimulusGroups"),
      stimGroupStim: "".concat(dbTablePrefix, "_stimulusGroupStimuli")
    };
    console.log("setting up main db connection with ".concat(JSON.stringify(connection)));
    this.knexInfo = {
      client: 'pg',
      version: '11',
      connection: connection,
      debug: true
    }; //fubar -- get rid of debug

    try {
      this.pg_main = (0, _knex["default"])(this.knexInfo);
    } catch (error) {
      console.error("Problem setting up on main db: ".concat(error));
      throw error;
    }

    console.log("check that we are connected to the main db");

    try {
      this.pg_main(this.tables.users).then(function (rows) {
        console.log("testing: " + rows);
      });
    } catch (error) {
      console.error("Problem with simple select from transaction DB: ".concat(error));
    }

    console.log("checking logging: ".concat(JSON.stringify(transactionOps)));
    this.logging = transactionOps ? true : false;

    if (this.logging) {
      try {
        this.trans_table = transactionOps.tableName;
        this.pg_trans = (0, _knex["default"])({
          client: 'pg',
          version: '11',
          connection: transactionOps.connection,
          debug: true
        }); //fubar get rid of debug when not needed
      } catch (error) {
        console.error("Problem setting up logger: ".concat(error));
        console.error("Turning off logging.");
        this.logging = false;
      }

      console.log("check that we are connected to the transaction db");

      try {
        this.pg_trans(this.trans_table).then(function (rows) {
          console.log("testing: " + rows);
        });
      } catch (error) {
        console.error("Problem with simple select from transaction DB: ".concat(error));
      }
    }

    console.log("Checked logging");
  }

  _createClass(DefaultHandler, [{
    key: "logTransaction",
    value: function () {
      var _logTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(knexCommand) {
        var toInsert, temp;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.logging) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", knexCommand);

              case 2:
                toInsert = {
                  //	query: knexCommand.toSQL().toNative().sql,
                  //	bindings: knexCommand.toSQL().toNative().bindings,
                  query: knexCommand.toString(),
                  bindings: '',
                  created_at: new Date()
                };
                _context2.prev = 3;
                console.log("logging transaction: ".concat(JSON.stringify(toInsert)));
                _context2.next = 7;
                return this.pg_trans(this.trans_table).insert({
                  query: mysql_real_escape_string(knexCommand.toString()),
                  bindings: '',
                  created_at: new Date()
                });

              case 7:
                temp = _context2.sent;
                console.log("sent to log: " + temp.toString());
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](3);
                console.error("Problem logging transaction: ".concat(_context2.t0));

              case 14:
                return _context2.abrupt("return", knexCommand);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 11]]);
      }));

      function logTransaction(_x) {
        return _logTransaction.apply(this, arguments);
      }

      return logTransaction;
    }()
  }, {
    key: "tabulateAndPostResults",
    value: function () {
      var _tabulateAndPostResults = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(sessId, data) {
        var results;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (sessId) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('startExperiment got invalid session id');

              case 2:
                if (data.user_id) {
                  _context3.next = 4;
                  break;
                }

                throw new Error('startExperiment got invalid userID');

              case 4:
                if (data.experiment) {
                  _context3.next = 6;
                  break;
                }

                throw new Error('startExperiment got invalid userID');

              case 6:
                results = {
                  message: "Completed this experiment with flying colors"
                }; //stub

                return _context3.abrupt("return", this.logTransaction(this.pg_main(this.tables.userResults).insert({
                  user_id: data.user_id,
                  experiment: data.experiment,
                  results: results,
                  created_at: new Date()
                })));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function tabulateAndPostResults(_x2, _x3) {
        return _tabulateAndPostResults.apply(this, arguments);
      }

      return tabulateAndPostResults;
    }()
  }, {
    key: "startExperiment",
    value: function () {
      var _startExperiment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(sessId, data, params) {
        var userId, toInsert, userCount, temp, returnVal;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (sessId) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('startExperiment got invalid session id');

              case 2:
                if (data.user_id) {
                  _context4.next = 4;
                  break;
                }

                throw new Error('startExperiment got invalid userID');

              case 4:
                userId = data.user_id;
                toInsert = {
                  user_id: userId,
                  created_at: new Date()
                };
                console.log('to insert:\n ', toInsert);
                _context4.prev = 7;
                _context4.next = 10;
                return this.pg_main(this.tables.users).where('user_id', userId).count('*');

              case 10:
                temp = _context4.sent;
                userCount = temp[0].count;
                _context4.next = 18;
                break;

              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](7);
                console.error("Problem checking if user exists: ".concat(_context4.t0));
                throw _context4.t0;

              case 18:
                console.log('userCount: ', userCount);

                if (!(userCount > 0)) {
                  _context4.next = 24;
                  break;
                }

                console.log("user ".concat(userId, " already exists. No need to recreate.")); //only need to insert if new subject

                return _context4.abrupt("return", {
                  user_id: userId
                });

              case 24:
                console.log("Adding ".concat(userId, " to users ").concat(this.tables.users, "."));
                _context4.prev = 25;
                returnVal = this.logTransaction(this.pg_main(this.tables.users).insert(toInsert));
                _context4.next = 33;
                break;

              case 29:
                _context4.prev = 29;
                _context4.t1 = _context4["catch"](25);
                console.error("Problem inserting user: ".concat(_context4.t1));
                throw _context4.t1;

              case 33:
                return _context4.abrupt("return", {
                  user_id: userId
                });

              case 34:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[7, 14], [25, 29]]);
      }));

      function startExperiment(_x4, _x5, _x6) {
        return _startExperiment.apply(this, arguments);
      }

      return startExperiment;
    }()
  }, {
    key: "getStimuli",
    value: function () {
      var _getStimuli = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(sessId, data) {
        var userId, nItems, selectedStims;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (sessId) {
                  _context5.next = 2;
                  break;
                }

                throw new Error('getStimuli got invalid session id');

              case 2:
                if (data.user_id) {
                  _context5.next = 4;
                  break;
                }

                throw new Error('getStimuli got invalid userID');

              case 4:
                userId = data.user_id;
                nItems = data.nItems;

                if (!data.nItems) {
                  _context5.next = 12;
                  break;
                }

                _context5.next = 9;
                return this.pg_main(this.tables.stim).select('stimulus').orderByRaw('random()').limit(nItems);

              case 9:
                _context5.t0 = _context5.sent;
                _context5.next = 15;
                break;

              case 12:
                _context5.next = 14;
                return this.pg_main(this.tables.stim).select('stimulus').orderByRaw('random()');

              case 14:
                _context5.t0 = _context5.sent;

              case 15:
                selectedStims = _context5.t0;
                return _context5.abrupt("return", selectedStims);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getStimuli(_x7, _x8) {
        return _getStimuli.apply(this, arguments);
      }

      return getStimuli;
    }()
  }, {
    key: "insertStimulusResponse",
    value: function () {
      var _insertStimulusResponse = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(sessId, data) {
        var toInsert;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (sessId) {
                  _context6.next = 2;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid session id');

              case 2:
                if (data.data_string) {
                  _context6.next = 4;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid response data string');

              case 4:
                if (data.user_id) {
                  _context6.next = 6;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid userID');

              case 6:
                if (data.data_string.stimulus) {
                  _context6.next = 8;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid stimulus');

              case 8:
                console.log("inserting response for user ".concat(data.user_id, ": ").concat(trim(JSON.stringify(data.data_string), 100)));
                toInsert = {
                  user_id: data.user_id,
                  stimulus: JSON.stringify(data.data_string.stimulus).substring(0, 1000),
                  response: JSON.stringify(data.data_string),
                  created_at: new Date()
                };
                console.log('to insert:\n ', toInsert);
                return _context6.abrupt("return", this.logTransaction(this.pg_main(this.tables.stimResp).insert(toInsert)));

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function insertStimulusResponse(_x9, _x10) {
        return _insertStimulusResponse.apply(this, arguments);
      }

      return insertStimulusResponse;
    }()
  }, {
    key: "insertMetaResponse",
    value: function () {
      var _insertMetaResponse = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(sessId, data) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (sessId) {
                  _context7.next = 2;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid session id');

              case 2:
                if (data.data_string) {
                  _context7.next = 4;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid response data string');

              case 4:
                if (data.user_id) {
                  _context7.next = 6;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid userID');

              case 6:
                if (data.stimulus) {
                  _context7.next = 8;
                  break;
                }

                throw new Error('insertStimulusResponse got invalid stimulus');

              case 8:
                console.log("inserting meta response for user ".concat(data.user_id, ": ").concat(trim(JSON.stringify(data.data_string), 100)));
                return _context7.abrupt("return", this.logTransaction(this.pg_main(this.tables.userMeta).insert({
                  user_id: data.user_id,
                  metaQuestion: JSON.stringify(data.stimulus),
                  metaResponse: JSON.stringify(data.data_string),
                  created_at: new Date()
                })));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function insertMetaResponse(_x11, _x12) {
        return _insertMetaResponse.apply(this, arguments);
      }

      return insertMetaResponse;
    }()
  }, {
    key: "methods",
    value: function methods() {
      var methods = ['getStimuli', 'insertStimulusResponse', 'startExperiment', 'insertMetaResponse', 'tabulateAndPostResults'];
      return methods;
    }
  }]);

  return DefaultHandler;
}();

module.exports = {
  defaultHandler: DefaultHandler,
  pushkinWorker: PushkinWorker
};